<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>iOS的Crash崩溃分类以及符号还原</title>
    <url>/2023/12/21/iOS%E7%9A%84Crash%E5%B4%A9%E6%BA%83%E5%88%86%E7%B1%BB%E4%BB%A5%E5%8F%8A%E7%AC%A6%E5%8F%B7%E8%BF%98%E5%8E%9F/</url>
    <content><![CDATA[<p>简单阐述了崩溃的产生原理, 崩溃的分类, 包括可捕获崩溃和一些无法被信号捕捉到的崩溃信息; 内测阶段以及线上崩溃发生时候如何监控这些崩溃并且解析出可识别的信息, 加快解决发生问题的速度.</p>
<span id="more"></span>

<h2 id="一-崩溃产生以及分类"><a href="#一-崩溃产生以及分类" class="headerlink" title="一 崩溃产生以及分类"></a>一 崩溃产生以及分类</h2><h2 id="二-符号以及符号化原理"><a href="#二-符号以及符号化原理" class="headerlink" title="二 符号以及符号化原理"></a>二 符号以及符号化原理</h2>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS安装包体积优化,可执行文件优化100M+体积</title>
    <url>/2023/12/16/iOS%E5%AE%89%E8%A3%85%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>精简安装包体积的一篇技术实操记录文, 主要记录了精简安装包体积过程中做了哪些操作, 调整一些编译参数以及链接参数, 利用LTO优化特性做了进一步的优化, 调整三方库的引入方式并且将三方库的配置信息进行了调整, 获取更大的优化空间.<br>同样也对比分析了代码覆盖率的分析手段以及自己对于这方面的认识, 包括不限于<code>Clang Plugin</code>,<code>Mach-O</code>分析,<code>LLVM Profile</code>等iOS系统底层知识。</p>
<p><strong>技术难点(省流):</strong><br>编译链接, Link Map, LTO优化, Mach-O结构, __TEXT段迁移, dyld执行流程, Clang插件,  LLVM插桩。</p>
<span id="more"></span>

<h2 id="一、-背景"><a href="#一、-背景" class="headerlink" title="一、  背景"></a>一、  背景</h2><p>最近(已是2023年12月)将2019年上线的包进行更新适配, 上线到App Store后发现安装包体积从原本的52M增加到了157M的大小。安装包体积增量100M, 明明什么大动作都没有做, 为什么安装包size会增加这么多? 大为震撼, 惊讶之余减包优化势在必行(拖延症关系大半月了才开始)。 </p>
<p>在安装包体积的要求上, 当然还有一些<a href="https://developer.apple.com/help/app-store-connect/reference/maximum-build-file-sizes">官方的原因</a>.</p>
<p><strong>App Store OTA 下载大小限制:</strong>  </p>
<ul>
<li><strong>iOS13</strong> 发布之后 <strong>iOS13</strong> 及以上用户可以使用流量下载超出 <strong>200MB</strong> 的 App， 但需要用户「<strong>设置</strong>」选择策略，默认为「超过 <strong>200MB</strong> 请求许可」，而 <strong>iOS13</strong> 以下用户仍然无法下载。</li>
<li>App 单架构主二进制 <code>__TEXT</code> 段上限为不超过 <strong>500MB</strong>。</li>
</ul>
<p><strong>官方文档《Doing basic optimization to reduce your app’s size》:</strong><a href="https://developer.apple.com/documentation/xcode/doing-basic-optimization-to-reduce-your-app-s-size">跳转🔗</a><br><img src="https://docs-assets.developer.apple.com/published/1076c8fcf1463c837b100bbb0c96219d/doing-basic-optimization-to-reduce-your-app-s-size-1@2x.png" alt="官方文档《Doing basic optimization to reduce your app’s size》"></p>
<hr>
<h2 id="二、-分析安装包组成"><a href="#二、-分析安装包组成" class="headerlink" title="二、 分析安装包组成"></a>二、 分析安装包组成</h2><p><code>Archive</code>打包以后, 我们可以从<code>ProjectName.xcarchive</code>中看到如下结构:</p>
<p><strong>iOS13 以后</strong> </p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> Info.plist </span><br><span class="line"><span class="bullet">2.</span> dSYM </span><br><span class="line"><span class="bullet">3.</span> Products</span><br></pre></td></tr></table></figure>

<p><strong>iOS13 以前</strong> </p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> Info.plist </span><br><span class="line"><span class="bullet">2.</span> dSYM </span><br><span class="line"><span class="bullet">3.</span> Products</span><br><span class="line"><span class="bullet">4.</span> swift.support</span><br></pre></td></tr></table></figure>
<p>经过<code>Archive</code>打包以后生成的<code>iPA</code>包, 其结构有所不同。<br><strong><code>iPA</code>包的结构如下:</strong> </p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Symbol:</span> </span><br><span class="line">	一些.Symbol </span><br><span class="line"><span class="symbol">Payload:</span></span><br><span class="line">	应用程序  </span><br></pre></td></tr></table></figure>
<p>查看<code>iPA</code>包的应用程序文件,我们可以清楚的看到如下的结构。<br><strong>应用程序的结构:</strong> </p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">Framework </span><br><span class="line">MachO文件(项目名开头可执行文件)</span><br><span class="line">_CodeSignature文件</span><br><span class="line"><span class="selector-class">.bundle</span>(库依赖包)</span><br><span class="line"><span class="selector-class">.nib</span>(如果使用)</span><br><span class="line"><span class="selector-class">.html</span>(如果使用)</span><br><span class="line"><span class="selector-class">.png</span>(如果使用)</span><br><span class="line">Other文件</span><br></pre></td></tr></table></figure>
<p>如果我们项目中使用到的本地文件, 存放的位置并没有放在<code>Assets.car</code>下, 而是放在了项目的普通Resources文件夹下的话, 则这一类处理的图片资源会在最终包里面, 不会经过Apple对<code>Assets.car</code>的额外压缩。因此, 需要我们在开发过程中尽可能把图片放在<code>Assets.car</code>下, 获取最大的压缩能力。</p>
<hr>
<h2 id="三、可执行文件优化"><a href="#三、可执行文件优化" class="headerlink" title="三、可执行文件优化"></a>三、可执行文件优化</h2><h3 id="可执行文件优化"><a href="#可执行文件优化" class="headerlink" title="可执行文件优化:"></a>可执行文件优化:</h3><h3 id="1-Strip符号-打包静态库"><a href="#1-Strip符号-打包静态库" class="headerlink" title="1. Strip符号&amp;打包静态库"></a>1. Strip符号&amp;打包静态库</h3><p>构建(<strong>Build</strong>)程序的过程中, 默认帮助我们生成可用于后期<strong>DEBUG</strong>的调试符号, 这些调试符号随着<code>ipa</code>包一起上传, 程序上线后我们可以通过<code>Xcode</code>查看奔溃上报, 如果我们有三方的崩溃监控或者完全不想用<code>Xcode</code>自带的崩溃, 我们可以 <a href="https://developer.apple.com/documentation/xcode/build-settings-reference/"><code>Strip</code></a> 这些调试符号, 这样可以进一步减小安装包的体积 </p>
<h3 id="2-静态库-动态库"><a href="#2-静态库-动态库" class="headerlink" title="2. 静态库&amp;动态库"></a>2. 静态库&amp;动态库</h3><p><a href="https://blog.csdn.net/a690197843/article/details/70241829">分析Pod中库间无用依赖</a> </p>
<ul>
<li>静态库，先解析<code>linkmap</code>数据，计算出<code>Pod模块</code>代码大小，解析<code>Pods-targetName-resource.sh</code>的资源拷贝代码，计算出拷贝到<code>Pod模块</code>的资源大小。 </li>
<li>动态库，先使用<code>lipo</code>拆分动态库的二进制文件，计算出单架构的代码大小，然后再计算动态库<code>framework</code>内的资源文件，得到动态库的资源文件大小。</li>
</ul>
<p>在此需要注意的是, 早期一些文章所述分离库文件中不需要的架构, 其实质上减少的是在打包过程中的包大小, 而最终<strong>AppStore</strong>的压缩包或者解压缩安装包的大小并不受影响, 关键在于<strong>Apple的Slicing</strong>自动拆分架构以适应当前用户设备可支持的架构, 故而并不需要我们额外处理.  </p>
<p>分拆库文件架构也并非没有收益, 其最终可以减少上传到<strong>TestFlight</strong>或者<strong>ADHoc</strong>等内测阶段的安装包体积, 加快<strong>Archive</strong>打包速度. 我们可以使用<code>lipo</code>命令对目标库文件进行拆分架构, 也可以<a href="https://github.com/GOATRobery/Utility-Script-/blob/main/libThin.sh">使用脚本</a>简化这步流程加快效率.</p>
<h3 id="2-1-库Symbol"><a href="#2-1-库Symbol" class="headerlink" title="2.1 库Symbol"></a>2.1 库Symbol</h3><p><code>Strip Style</code>表示的是我们需要去除的符号的类型的选项，其分为三个选择项： </p>
<ul>
<li><code>All Symbols</code>: 去除所有符号，一般是在主工程中开启。</li>
<li><code>Non-Global Symbols</code>: 去除一些非全局的 Symbol（保留全局符号，Debug Symbols 同样会被去除），链接时会被重定向的那些符号不会被去除，此选项是静态库&#x2F;动态库的建议选项。</li>
<li><code>Debug Symbols</code>: 去除调试符号，去除之后将无法断点调试。</li>
</ul>
<p><code>Strip Linked Product</code>:<br><code>Xcode</code> 提供给我们 <code>Strip Linked Product</code> 来去除不需要的符号信息(<code>Strip Style</code> 中选择的选项相应的符号)，去除了符号信息之后我们就只能使用 <code>dSYM</code> 来进行符号化了，所以需要将 <code>Debug Information Format</code> 修改为 <code>DWARF with dSYM file</code>。</p>
<p><code>Strip Debug Symbols During Copy</code>:<br><code>Strip Linked Product</code> 类似，但是这个是将那些拷贝进项目包的三方库、资源或者 Extension 的 <code>Debug Symbol</code> 去除掉，同样也是使用的 <code>strip</code> 命令。这个选项没有前置条件，所以我们只需要在 <code>Release</code> 模式下开启，不然就不能对三方库进行断点调试和符号化了。</p>
<p><code>Cocoapods</code> 管理的动态库(<code>use_framework!</code>)的情况就相对要特殊一点，因为 <code>Cocoapods</code> 中的<code>动态库</code>是使用自己实现的脚本 <code>Pods-xxx-frameworks.sh</code> 来实现拷贝的，所以并不会走 <code>Xcode</code> 的流程，当然也就不受 <code>Strip Debug Symbols During Copy</code> 的影响。当然<code>Cocoapods</code> 是源码管理的，所以只需要将源码<code>Target 中的 Strip Linked Product</code> 设置为 <code>YES</code> 即可。 </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$static_framework</span> = [<span class="string">&#x27;SDWebImage&#x27;</span>, <span class="string">&#x27;AFNetworking&#x27;</span>]</span><br><span class="line">pre_install <span class="keyword">do</span> |<span class="params">install</span>|</span><br><span class="line">  puts install</span><br><span class="line">  install.pod_targets.each &#123;|<span class="params"> pod </span>|</span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$static_framework</span>.<span class="keyword">include</span>?(pod.name)</span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">pod</span>.build_type;</span><br><span class="line">        <span class="title class_">Pod</span><span class="symbol">:</span><span class="symbol">:BuildType</span>.static_framework <span class="comment"># 使用静态库</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">end</span>  </span><br></pre></td></tr></table></figure>

<p>可以通过如上设置, 配置<code>pod</code>的<code>config</code>, 保证每次<code>pod</code>更新库配置都可以保持一致。<br>注:遴选库为静态方式引入项目. </p>
<p><strong>补充:</strong><br>设置 <code>STRIP_STYLE= all</code> 来裁剪所有符号。但通过：</p>
<blockquote>
<p>objdump -exports-trie &#x2F;path&#x2F;to&#x2F;MyApp.app&#x2F;MyApp </p>
</blockquote>
<p>还能获取到可执行文件中的符号，这部分可以通过设置 <code>EXPORTED_SYMBOLS_FILE</code> 为一个空文件解决 <code>EXPORTED_SYMBOLS_FILE=/path/to/emptyfile.txt</code> 。</p>
<p>对于自己构建的动态库。只需要保留未定义的符号以及全局的符号其他的都可以去除。通常设置<code>STRIP_STYLE=non-global</code>。  </p>
<h3 id="3-LOT优化"><a href="#3-LOT优化" class="headerlink" title="3. LOT优化"></a>3. LOT优化</h3><p><strong>开启LTO优化配置:</strong><br>链接期优化参数：<code>LLVM</code>提供链接期编译优化, 通过设置工程中的<code>Link-Time Optimization </code>进行控制。<br>提供以下几个选项： </p>
<ul>
<li><code>No</code> 不开启链接期优化;  </li>
<li><code>Fastest[-O3]</code>: 在开启<code>Fast[-O1]</code>项支持的所有优化项的同时，开启函数内联和寄存器重命名选项。这个设置有可能会导致二进制文件变大。</li>
<li><code>Fastest, Smallest[-Os]</code>: 优化大小。这个设置开启了<code>Fast[-O1]</code>项中的所有不增加代码大小的优化选项，并会进一步的执行可以减小代码大小的优化。</li>
<li><code>Fastest, Aggressive Optimizations[-Ofast]</code>: 这个设置开启了<code>Fastest[-O3]</code>中的所有优化选项，同时也开启了可能会打破严格编译标准的积极优化，但并不会影响运行良好的代码。</li>
<li><code>Smallest, Aggressive Size Optimizations [-Oz]</code>: 与相似<code>-Os</code>，但会进一步减小代码大小，并且可能需要更长的时间才能运行。</li>
</ul>
<p><strong>Release模式下采用最高优化等级:</strong><br><code>Build Settings-Optimization Level</code>在<code>Release</code>模式下设置为<code>[-Oz]</code>, 该设置通过将重复的代码模式隔离到编译器生成的函数中来实现额外的尺寸, 最大程度的优化生成的包体积,<br>更多信息请参考<a href="https://help.apple.com/xcode/mac/11.4/#/itcaec37c2a6">官方文档链接</a>。</p>
<h3 id="4-死代码剥离-Dead-Code-Strip"><a href="#4-死代码剥离-Dead-Code-Strip" class="headerlink" title="4. 死代码剥离(Dead Code Strip)"></a>4. 死代码剥离(<code>Dead Code Strip</code>)</h3><p><strong>官方描述:</strong><br><code>Activating this setting causes the -dead_strip flag to be   passed to ld(1) via cc(1) to turn on dead code stripping.</code></p>
<p><strong>Xcode默认开启选项：</strong><code>Xcode</code>在默认情况下会开启移除未使用代码的选项。这意味着在编译过程中，编译器会尽可能地移除未被使用的代码，以减少生成的可执行文件的大小和提高性能。 </p>
<p><strong>C&#x2F;C++&#x2F;Swift等静态语言</strong>：这些编译器在链接阶段会移除未使用的代码。静态语言的特性使得编译器在链接时能够准确地确定哪些代码被使用，因此可以安全地删除未使用的部分。 </p>
<p><strong>Objective-C等动态语言</strong>：与静态语言不同，Objective-C等动态语言是建立在运行时上的。在Objective-C中，对象的创建和方法的调用等操作发生在运行时。因此，底层暴露给编译器的是Runtime源码的编译结果，这使得编译器无法在编译时准确地确定哪些代码会被使用。因此，对于<strong>Objective-C等动态语言，移除未使用代码的操作通常是无效的，因为在运行时才能确定代码的有效性</strong>。</p>
<h3 id="5-OC、C-C-Exception剥离"><a href="#5-OC、C-C-Exception剥离" class="headerlink" title="5. OC、C&#x2F;C++Exception剥离"></a>5. OC、C&#x2F;C++Exception剥离</h3><p><strong>异常捕获机制:</strong><br><code>Enable C++ Exceptions</code>和<code>Enable Objective-C Exceptions</code>是指项目对错误的异常处理，比如<code>try catch</code>， <code>throw</code>之类的语句；所以如果你的项目中有类似的处理，关闭这个之后会报错<code>Cannot use &#39;@try&#39; with Objective-C exceptions disabled</code>。如果宏定义有<code>try</code>，关闭之后也会报错。</p>
<p>如果你的项目中可以设置关闭捕获异常的开关，还需要另外设置<code>Build Settings-Other Link Flags</code>去添加一个字段<code>-fno-exceptions</code>代表禁用异常机制。 </p>
<p>OC的该选项, 因为有一些诸如<code>@weak</code>等操作的存在, 去除之后编译则会报错, 若项目有如同样操作, 不建议去除。</p>
<h3 id="6-重复代码"><a href="#6-重复代码" class="headerlink" title="6. 重复代码"></a>6. 重复代码</h3><h3 id="6-1-静态分析重复-无用代码"><a href="#6-1-静态分析重复-无用代码" class="headerlink" title="6.1 静态分析重复&#x2F;无用代码"></a>6.1 静态分析重复&#x2F;无用代码</h3><p><strong>AppCode&#x2F;fui等工具,基于源码扫描:</strong><br>基于脚本做正则匹配, 误判概率很高, 如果是小型项目使用AppCode则完全足够了。动态化逻辑比较多的项目不推荐.</p>
<p><strong>Mach-O信息分析:</strong><br><code>__DATA __objc_classrefs</code> 段记录了引用类的地址，<code>__DATA __objc_classlist</code>段记录了所有类的地址，取差集可以得到未使用的类的地址，然后进行符号化，就可以得到未被引用的类信息。<br><a href="https://zhuanlan.zhihu.com/p/344821756">详情请参考:https://zhuanlan.zhihu.com/p/344821756</a></p>
<p><strong>Clang插件扫描:</strong> </p>
<h3 id="6-2-动态分析重复-无用代码"><a href="#6-2-动态分析重复-无用代码" class="headerlink" title="6.2 动态分析重复&#x2F;无用代码"></a>6.2 动态分析重复&#x2F;无用代码</h3><p>C&#x2F;C++&#x2F;Swift等静态语言, 在编译时即可确定代码的调用关系, 但是如<strong>Objective-C</strong>动态语言, 则只可在运行时确定代码的调用关系. 以上静态分析的方式存在一定的局限性, 需要我们作出更多努力.<br><strong>基于Runtime的metaclass初始化位标记:</strong><br>程序启动时, 因为<a href="https://developer.aliyun.com/article/924936?spm=a2c6h.24874632.expert-profile.43.393013000BVrBO"><code>dyld</code>处理逻辑</a>的关系, 在<strong>Process-in</strong>会<strong>load</strong>所有类以及分类并主动调用他们的<strong>load()<strong>方法. 正是如此, 我们参考 <strong>load()<strong>方法的执行与否并不能确定一个类是否真正使用到了.<br>同</strong>load()<strong>方法类似的</strong>initialize()<strong>方法, 亦是类在首次真正使用时调用该方法, 并且</strong>Class</strong>结构中</strong>metaClass</strong>有一个<strong>flag</strong>标记位可以用来显示<strong>initialize</strong>的调用状态, 该<strong>flag</strong>标记位为<a href="https://github.com/apple-oss-distributions/objc4/blob/main/runtime/objc-runtime-new.h"><strong>RW_INITIALIZED</strong></a>时则表明该类已经被真正调用.</p>
<p><strong>基于GCOV&#x2F;LLVM Profile的二进制插桩:</strong><br><a href="https://tech.meituan.com/2018/12/27/ios-increment-coverage.html">增量代码覆盖率监控</a></p>
<h3 id="7-Asset-car图片压缩空间配置"><a href="#7-Asset-car图片压缩空间配置" class="headerlink" title="7. Asset.car图片压缩空间配置"></a>7. Asset.car图片压缩空间配置</h3><p>设置<code>Build Settings-Asset Catalog Compiler Options-Optimization设置为space；</code><br>可以改变actool在构建Assets.car时选取的编码压缩算法。  </p>
<p>使用如下命令,可以把对应信息生成.json文件，用于对比不同:<br><code>xcrun --sdk iphoneos assetutil --info Assets.car &gt; Assets.json</code></p>
<h3 id="8-TEXT段加密绕过-iOS12及以前"><a href="#8-TEXT段加密绕过-iOS12及以前" class="headerlink" title="8. _TEXT段加密绕过(iOS12及以前)"></a>8. _TEXT段加密绕过(<code>iOS12及以前</code>)</h3><h3 id="8-1-TEXT-段迁移"><a href="#8-1-TEXT-段迁移" class="headerlink" title="8.1 __TEXT 段迁移"></a>8.1 <code>__TEXT</code> 段迁移</h3><p><code>Apple</code>官方会将<strong>Mach-O</strong>的<code>__TEXT</code>段进行<a href="https://tech.meituan.com/2021/11/25/fairplay-drm.html">Fairplay</a>加密, 这个加密方式可能会对安装包的压缩比例产生影响, 从而影响到最终压缩包的大小. </p>
<p>如果我们可以把<code>__TEXT</code>段中一些不必要的内容转移走, 规避掉加密行为, 那么我们在<code>__TEXT</code>段上的压缩有所收益.  </p>
<p>在此需要注意的是, <a href="https://juejin.cn/post/6911121493573402638#heading-17"><code>__TEXT</code>段迁移</a>降低的是下载的大小, 即下载压缩包的大小, <code>App Store</code>上显示的包大小, 即解压缩后实际安装大小则变化不明显.</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">-Wl,-rename_section,<span class="variable">__TEXT</span>,<span class="variable">__cstring</span>,<span class="variable">__RODATA</span>,<span class="variable">__cstring</span></span><br><span class="line">-Wl,-rename_section,<span class="variable">__TEXT</span>,<span class="variable">__objc_methname</span>,<span class="variable">__RODATA</span>,<span class="variable">__objc_methname</span></span><br><span class="line">-Wl,-rename_section,<span class="variable">__TEXT</span>,<span class="variable">__objc_classname</span>,<span class="variable">__RODATA</span>,<span class="variable">__objc_classname</span></span><br><span class="line">-Wl,-rename_section,<span class="variable">__TEXT</span>,<span class="variable">__objc_methtype</span>,<span class="variable">__RODATA</span>,<span class="variable">__objc_methtype</span></span><br><span class="line">-Wl,-rename_section,<span class="variable">__TEXT</span>,<span class="variable">__gcc_except_tab</span>,<span class="variable">__RODATA</span>,<span class="variable">__gcc_except_tab</span></span><br><span class="line">-Wl,-rename_section,<span class="variable">__TEXT</span>,<span class="variable">__const</span>,<span class="variable">__RODATA</span>,<span class="variable">__const</span></span><br><span class="line">-Wl,-rename_section,<span class="variable">__TEXT</span>,<span class="variable">__dof_RACCompou</span>,<span class="variable">__RODATA</span>,<span class="variable">__dof_RACCompou</span></span><br><span class="line">-Wl,-rename_section,<span class="variable">__TEXT</span>,<span class="variable">__dof_RACSignal</span>,<span class="variable">__RODATA</span>,<span class="variable">__dof_RACSignal</span></span><br><span class="line">-Wl,-rename_section,<span class="variable">__TEXT</span>,<span class="variable">__text</span>,<span class="variable">__WB_TEXT</span>,<span class="variable">__text</span></span><br><span class="line">-Wl,-rename_section,<span class="variable">__TEXT</span>,<span class="variable">__stubs</span>,<span class="variable">__WB_TEXT</span>,<span class="variable">__stubs</span></span><br><span class="line">-Wl,-rename_section,<span class="variable">__TEXT</span>,<span class="variable">__textcoal_nt</span>,<span class="variable">__WB_TEXT</span>,<span class="variable">__text</span>,</span><br><span class="line">-Wl,-rename_section,<span class="variable">__TEXT</span>,<span class="variable">__StaticInit</span>,<span class="variable">__WB_TEXT</span>,<span class="variable">__text</span></span><br><span class="line">-Wl,-segprot,<span class="variable">__WB_TEXT</span>,rx,rx</span><br></pre></td></tr></table></figure>
<p>迁移过后<code>Mac-O</code>中<code>LoadCommand</code>结构:<br><img src="https://github.com/GOATRobery/common-Resources/blob/main/images/rename_section_TEXT.jpg?raw=true" alt="LC_TEXT"> </p>
<p><code>__TEXT</code>段迁移之后, iOS12.5版本真机测验其压缩的包比例确如所说, 压缩比例在30%左右。</p>
<p>注⚠️: 同样可以基于链接优化启动速度 </p>
<ul>
<li><code>Page In</code>时，<code>__TEXT</code> 段的页解密很耗时</li>
<li>可以通过 <code>ld</code> 的<code>-rename_section</code>，把 <code>__TEXT</code> 段中的内容，比如字符串移动到其他的段(启动路径上难免会读很多字符串)，从而规避这个解密的耗时。</li>
</ul>
<p><strong>Swift在段上的分布:</strong>   </p>
<p><img src="https://raw.githubusercontent.com/GOATRobery/common-Resources/main/images/640.webp">  </p>
<p>数据详细描述: <a href="https://knight.sc/reverse%20engineering/2019/07/17/swift-metadata.html">参考链接</a></p>
<h3 id="8-2-二进制压缩"><a href="#8-2-二进制压缩" class="headerlink" title="8.2 二进制压缩"></a>8.2 二进制压缩</h3><h3 id="9-BitCode优化-Xcode-14以前"><a href="#9-BitCode优化-Xcode-14以前" class="headerlink" title="9. BitCode优化(Xcode 14以前)"></a>9. BitCode优化(<code>Xcode 14以前</code>)</h3><p><strong>BitCode:</strong><br>位码是已编译程序的中间表示形式。(我们上传到<strong>App Store Connect</strong>的包含位码的应用程序将被编译并链接到<strong>App Store</strong>上。包含位码将允许苹果在未来重新优化你的应用二进制，而无需向<strong>App Store</strong>提交新版本的应用), 在打包发版本阶段, 大多时候我们并不需要这一中间产物。 </p>
<p><strong>Xcode 14</strong>自动帮我们设置为 <code>NO</code>, <a href="https://developer.apple.com/documentation/Xcode-Release-Notes/xcode-14-release-notes#Deprecations">官方自Xcode14开始废弃Bitcode</a>。</p>
<h3 id="10-静态扫描工具推荐"><a href="#10-静态扫描工具推荐" class="headerlink" title="10. 静态扫描工具推荐"></a>10. 静态扫描工具推荐</h3><ul>
<li><a href="https://github.com/wuba/WBBlades">WBBlades (基于otool+mach-o的检测技术)</a></li>
</ul>
<hr>
<h2 id="四、-资源优化"><a href="#四、-资源优化" class="headerlink" title="四、 资源优化"></a>四、 资源优化</h2><h3 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化:"></a>资源优化:</h3><h3 id="1-无用资源清理"><a href="#1-无用资源清理" class="headerlink" title="1. 无用资源清理"></a>1. 无用资源清理</h3><p>主要是重复图片资源, 长期迭代下来难免有重复的图片, 这些重复的图片没有必要双份或者多份。 简单高效的处理手段就是使用筛选脚本工具, 这些工具大多通过正则匹配的方式扫描代码中<code>imageNamed:</code>或<code>imageWithContentsOfFile:</code>是否有包含图片名或图片名拼接的方式引入项目。 工具有很多,在此不一一列举。  </p>
<p>实际操作过程中, 我们发现很多图片会有误判的情况, 筛选只是第一步, 逐个确认是否使用记录使用模块, 最后验证确认等才是最主要的工作内容。</p>
<p><img src="https://github.com/GOATRobery/common-Resources/blob/main/1_TAxGbMd_ZrFFR6qlC_9m7g.gif?raw=true" alt="LSUnusedResources"></p>
<h3 id="2-重复或类似资源资源合并"><a href="#2-重复或类似资源资源合并" class="headerlink" title="2. 重复或类似资源资源合并"></a>2. 重复或类似资源资源合并</h3><ul>
<li>重复图片精简</li>
<li>库文件重复逻辑合并, 共同依赖底层功能如<code>OpenSSL</code>抽离成动态库, 链接阶段<code>share cache</code></li>
</ul>
<h3 id="3-资源压缩"><a href="#3-资源压缩" class="headerlink" title="3. 资源压缩"></a>3. 资源压缩</h3><p><strong>避免无损压缩:</strong> </p>
<p><strong>Xcode</strong>中，构建<strong>Asset Catalog</strong>的工具<strong>actool</strong>会首先对<strong>Asset Catalog</strong>中的 <strong>png</strong> 图片进行解码，得到<strong>Bitmap</strong>数据，然后再运用<strong>actool</strong>的编码压缩算法进行编码压缩处理。无损压缩通过变换图片的编码压缩算法减少大小，但是不会改变<strong>Bitmap</strong> 数据。对于<strong>actool</strong>来说，它接收的输入没有改变，所以无损压缩无法优化<strong>Assets.car</strong>的大小。 </p>
<p><strong>压缩策略:</strong>  </p>
<ul>
<li>采用有损压缩方式, 最大化Apple图片压缩优化比例。  </li>
<li>更换显示图片文件格式, 如: <code>HEIC</code>、<code>iconfront</code>、<code>.webpg</code>、<code>.pdf</code>、<code>.svg</code>等。<br>未证实说法: 使用<code>pdf</code>格式图片, Apple自动转化为所需要的图片。</li>
</ul>
<p>除图片资源外, 视频、音频等本地资源也可压缩文件的体积。</p>
<h3 id="4-本地资源远端加载-远端服务器请求-官方ODR"><a href="#4-本地资源远端加载-远端服务器请求-官方ODR" class="headerlink" title="4. 本地资源远端加载(远端服务器请求&#x2F;官方ODR)"></a>4. 本地资源远端加载(远端服务器请求&#x2F;官方ODR)</h3><p><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/index.html#//apple_ref/doc/uid/TP40015083">On Demand Resources</a>延迟加载资源, 通过设置<code>Resources Tag</code>标记位, 可选择随包下载以及按需加载资源。  </p>
<ul>
<li><code>Initial install tags</code>: 此种标签的资源，会随着 app 从 App Store 下载而下载，但是会影响 app 的 ipa 大小，也就是说此种资源会包含在 ipa 内。和开发工具默认行为一致 </li>
<li><code>Prefetch tag order</code>: 此种标签会在 app 下载后，开始下载相应的资源，此种资源并不会影响 ipa 的大小，也就是说此种资源并不包含在 ipa 内。此场景常用游戏场景，不过多赘述 </li>
<li><code>Dowloaded only on demand</code>: 此种标签下的资源，会在必要的时候，主动触发下载，这是我们开发者自己控制下载时机的。</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>引用自<a href="https://live.byteoc.com/9281/2083745">字节跳动技术分享沙龙直播</a>内容。  </p>
<p><strong>安装包体积优化方案总结:</strong><br><img src="https://github.com/GOATRobery/common-Resources/blob/e37c50bdae470efcf81329b00f5dd58e648bd9cf/%E5%AE%89%E8%A3%85%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93.png?raw=true" alt="安装包体积优化方案总结"></p>
<p><strong>无用代码筛查:</strong><br><img src="https://github.com/GOATRobery/common-Resources/blob/e37c50bdae470efcf81329b00f5dd58e648bd9cf/%E6%97%A0%E7%94%A8%E4%BB%A3%E7%A0%81%E7%AD%9B%E6%9F%A5.png?raw=true" alt="无用代码筛查">   </p>
<p><strong>编译配置优化:</strong><br><img src="https://raw.githubusercontent.com/GOATRobery/common-Resources/main/images/zoom-in-crop-mark_1512_0_0_0.webp" alt="编译配置优化"></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://developer.apple.com/documentation/xcode/build-settings-reference/">Xcode配置说明官方文档</a>  </li>
<li><a href="https://help.apple.com/xcode/mac/11.4/#/itcaec37c2a6?sub=dev881878d77">Xcode配置参数说明</a></li>
<li><a href="https://mp.weixin.qq.com/s/I6DH5RvkMh_-bxGpkAKBPA">Alibaba安装包瘦身(精华)</a></li>
<li><a href="https://blog.csdn.net/ByteDanceTech/article/details/112504772">抖音品质建设 - iOS 安装包大小优化实践篇</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/516628980">搜狐技术,iOS包体积优化</a></li>
<li><a href="https://mp.weixin.qq.com/s/_Mvl0FGriKsvAyRheU2Z7w">搜狐技术,正经分析包体积优化</a></li>
<li><a href="https://sq.sf.163.com/blog/article/200384401846304768">网易Cocoapods 中的优化选项配置</a></li>
<li><a href="https://mp.weixin.qq.com/s/oyqAa8wKdioI5ZDG5LjkfA">今日头条减包(大部分已过时)</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247487459&idx=1&sn=3dd9276f5af78ca5a377adec37e3e916&chksm=e9d0c401dea74d17e9f1bdd5ea764cc0cd7e845c6ebadde752d36608306b09e762a1681c7252&scene=21#wechat_redirect">今日头条二进制压缩减包</a></li>
<li><a href="https://tech.meituan.com/2018/12/27/ios-increment-coverage.html">美团代码覆盖率检测</a></li>
<li><a href="https://my.oschina.net/u/4939618/blog/10112383">百度Clang插件静态扫描无用代码</a> </li>
<li><a href="https://blog.gocy.tech/2017/09/12/DetectingUselessCodeWithClang-p1/">Clang插件实践</a></li>
<li><a href="https://www.zybuluo.com/qidiandasheng/note/1662385">PMD扫描未使用项目源码</a></li>
<li><a href="https://mp.weixin.qq.com/s/QFtlp0sG4eJRZ7NrDMAopw">基于Mach-O的静态扫描(58技术)</a></li>
<li><a href="https://www.jianshu.com/p/c41ad330e81c">基于Mach-O的反汇编无用类检测(竹立佬)</a> </li>
<li><a href="https://medium.com/@manojaher/app-size-reduction-903a04646e3a">App size-reduction Optimizing builds for lesser sizes</a></li>
<li><a href="https://juejin.cn/post/7260819638123380793">upsteam安装包大小优化笔记</a></li>
</ul>
<!--more-->]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS应用内购买</title>
    <url>/2024/04/30/iOS%E5%BA%94%E7%94%A8%E5%86%85%E8%B4%AD%E4%B9%B0/</url>
    <content><![CDATA[<h3 id="Apple官方内购流程图"><a href="#Apple官方内购流程图" class="headerlink" title="Apple官方内购流程图:"></a>Apple官方内购流程图:</h3><p><img src="https://raw.githubusercontent.com/GOATRobery/common-Resources/main/images/apple_offical_in_app_purchase.webp" alt="Apple官方内购流程图"> </p>
<ul>
<li>1.程序向服务器发送请求，获得一份产品列表。</li>
<li>2.服务器返回包含产品标识符的列表。</li>
<li>3.程序向App Store发送请求，得到产品的信息。</li>
<li>4.App Store返回产品信息。</li>
<li>5.程序把返回的产品信息显示给用户（App的store界面）</li>
<li>6.用户选择某个产品</li>
<li>7.程序向App Store发送支付请求</li>
<li>8.App Store处理支付请求并返回交易完成信息。</li>
<li>9.程序从信息中获得数据，并发送至服务器。</li>
<li>10.服务器纪录数据，并进行审(我们的)查。</li>
<li>11.服务器将数据发给App Store来验证该交易的有效性。</li>
<li>12.App Store对收到的数据进行解析，返回该数据和说明其是否有效的标识。</li>
<li>13.服务器读取返回的数据，确定用户购买的内容。</li>
<li>14.服务器将购买的内容传递给程序</li>
</ul>
<h3 id="内购商品一共有四种类型："><a href="#内购商品一共有四种类型：" class="headerlink" title="内购商品一共有四种类型："></a>内购商品一共有四种类型：</h3><h4 id="消耗型："><a href="#消耗型：" class="headerlink" title="消耗型："></a>消耗型：</h4><p>可以购买多次，多次结果累加，并且在App内作为“货币”消耗。典型的是虚拟货币，用户先通过IAP购买虚拟货币，再消耗虚拟货币购买商品。  </p>
<h4 id="非消耗型："><a href="#非消耗型：" class="headerlink" title="非消耗型："></a>非消耗型：</h4><p>同一个Apple ID只能购买一次，可跨设备使用，业务场景较少。典型的是图书App中的一本电子书，或者游戏中的一个关卡。  </p>
<h4 id="自动续期订阅："><a href="#自动续期订阅：" class="headerlink" title="自动续期订阅："></a>自动续期订阅：</h4><p>和时间相关的服务，在有效期内用户可享受服务，到期后自动扣费，退订需要到Apple ID的管理后台操作。典型的是连续包月的会员。自动续期订阅还可以加优惠活动。  </p>
<h4 id="非续期订阅："><a href="#非续期订阅：" class="headerlink" title="非续期订阅："></a>非续期订阅：</h4><p>和时间相关的服务，但是不会自动扣费。  </p>
<p>在新建了商品之后，这个商品ID是无法修改的。一个开发者账号内，一个商品ID只能使用一次，不能在当前开发者账号下的其他app内配置这个商品ID，如果删除后也不能重新添加这个商品ID。<br>同时，新建了商品后，这个商品的商品类型无法变更。所以需要谨慎选择商品ID和商品类型。</p>
<h3 id="涉及API"><a href="#涉及API" class="headerlink" title="涉及API"></a>涉及API</h3><h4 id="内购"><a href="#内购" class="headerlink" title="内购"></a>内购</h4><ul>
<li><strong>iOS15</strong>开始, 使用<strong>JSON Web Signature</strong> (JWS)作为交易验证签名的格式.  </li>
<li>如果项目开发满足系统版本要求, 亦可用作<code>visionOS</code>的多场景<strong>API</strong>.</li>
</ul>
<h4 id="原内购"><a href="#原内购" class="headerlink" title="原内购"></a>原内购</h4><ul>
<li>iOS3开始</li>
</ul>
<h3 id="IAP支付流程-服务器验证流程"><a href="#IAP支付流程-服务器验证流程" class="headerlink" title="IAP支付流程 &amp; 服务器验证流程"></a>IAP支付流程 &amp; 服务器验证流程</h3><p> 整个支付流程如下： </p>
<ul>
<li>1.客户端向Appstore请求购买产品（假设产品信息已经取得），Appstore验证产品成功后，从用户的Apple账户余额中扣费。   </li>
<li>2.Appstore向客户端返回一段receipt-data，里面记录了本次交易的证书和签名信息。   </li>
<li>3.客户端向我们可以信任的服务器提供receipt-data   </li>
<li>4.服务器对receipt-data进行一次base64编码   </li>
<li>5.服务器把编码后的receipt-data发往itunes.appstore进行验证   </li>
<li>6.itunes.appstore返回验证结果给服务器   </li>
<li>7.服务器对商品购买状态以及商品类型，向客户端发放相应的道具与推送数据更新通知</li>
</ul>
<h3 id="服务端开发"><a href="#服务端开发" class="headerlink" title="服务端开发"></a>服务端开发</h3><p>内购的过程，客户端开发工作量并不大，工作的重难点在于后端的设计和开发。</p>
<h4 id="基于收据的校验模式"><a href="#基于收据的校验模式" class="headerlink" title="基于收据的校验模式"></a>基于收据的校验模式</h4><p>获取了收据之后我们可以继续验证收据是否合法。为了防止应用被黑，最好的方式是将校验逻辑放在后端来执行。相关的文档位于 <a href="https://developer.apple.com/documentation/storekit/in-app_purchase/original_api_for_in-app_purchase/validating_receipts_with_the_app_store?language=objc">《Validating receipts with the App Store》</a>.<br>验证收据的逻辑，这里提供 Python 和 Java 两套实现代码。可以在测试验证的时候使用 Python，开发服务器的时候使用 java 代码。接口信息位于文档 <a href="https://developer.apple.com/documentation/appstorereceipts/verifyreceipt">《verifyreceipt》</a>. 即通过 http 协议发送一个请求到服务器，将收据的信息做 base64 编码之后通过 post 的形式以 json 传递给 Apple 服务器。  </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import requests, json</span><br><span class="line"></span><br><span class="line">receipt = <span class="string">&quot;你的收据&quot;</span></span><br><span class="line">url = <span class="string">&#x27;https://sandbox.itunes.apple.com/verifyReceipt&#x27;</span></span><br><span class="line">headers = &#123;<span class="string">&quot;Content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span>&#125;</span><br><span class="line">data = json.dumps(&#123;<span class="string">&quot;receipt-data&quot;</span>: receipt&#125;)</span><br><span class="line">res = requests.post(<span class="attribute">url</span>=url, <span class="attribute">data</span>=data, <span class="attribute">headers</span>=headers, <span class="attribute">verify</span>=<span class="literal">False</span>).text</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<p>以及 java 版（基于 OkHttp 进行网络请求）  </p>
<pre><code>public static void main(String...args) throws IOException &#123;  

  String receipt = &quot;你的收据&quot;;
  JsonObject jsonObject = new JsonObject();
  jsonObject.addProperty(&quot;receipt-data&quot;, receipt);  
  
  RequestBody body = RequestBody.create(MediaType.parse(&quot;application/json; charset=utf-8&quot;), jsonObject.toString());  
  
  Request request = new Request.Builder()
          .header(&quot;Content-type&quot;, &quot;application/json&quot;)
          .url(&quot;https://sandbox.itunes.apple.com/verifyReceipt&quot;)
          .post(body)
          .build();
  OkHttpClient client = new OkHttpClient.Builder()
          .build();
  Response response;  
  
  try &#123;
      response = client.newCall(request).execute();  
      
      System.out.println(response.body().string());  
      
  &#125; catch (IOException e) &#123;  
  
      e.printStackTrace();
  &#125;
&#125;  
</code></pre>
<p>输出的结果是一行 json，其中包含字段 status 为 0. 收据的详细字段说明可以参考文档 <a href="https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW8">《Receipt Validation Programming Guide》</a>.</p>
<h4 id="验证签名是否有无过期"><a href="#验证签名是否有无过期" class="headerlink" title="验证签名是否有无过期"></a>验证签名是否有无过期</h4><ul>
<li><p>确保使用的<code>receipt_creation_date </code>字段中的数据来验证签名.</p>
</li>
<li><p>推荐使用SHA-256 和 SHA-1 算法.</p>
</li>
<li><p><code>latest_receipt</code>字段包含最新的收据信息.</p>
</li>
<li><p><code>latest_receipt_info</code>字段包含初始购买和后续续订.</p>
</li>
<li><p><code>expiration_intent </code>字段获取过期原因.</p>
</li>
<li></li>
<li><p>使用IDFV签名下的UUID&#x2F;uuid</p>
</li>
</ul>
<h3 id="特别需要注意"><a href="#特别需要注意" class="headerlink" title="特别需要注意"></a>特别需要注意</h3><ul>
<li>所有内购的功能在未发布到应用商店之前, 都只能使用沙盒测试.</li>
<li>服务端以及iOS端, 都需要明确区分沙盒测试和线上实际使用的环境区分. 服务端使用对应的验证接口.</li>
<li>签名时间与当前时间的验证, 当选取<code>东8区</code>时间作为参考时间.</li>
<li>内购项目对应的服务字段,亦当服务端获取, 灵活调整相应价格.</li>
</ul>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><p>StoreKit和StoreKit2</p>
<p>三种状态: 新用户, 当前处于订阅, 过往存在订阅</p>
<p>非续订订阅<br>自动续订订阅</p>
<p>当用户订阅过期, 如果配置了计费宽限期, 最多可在60日内恢复订阅.</p>
<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><ul>
<li><a href="https://developer.apple.com/cn/documentation/storekit/in-app_purchase/">https://developer.apple.com/cn/documentation/storekit/in-app_purchase&#x2F;</a> </li>
<li><a href="https://developer.apple.com/documentation/storekit/in-app_purchase/choosing_a_storekit_api_for_in-app_purchases?language=objc">https://developer.apple.com/documentation/storekit/in-app_purchase&#x2F;choosing_a_storekit_api_for_in-app_purchases?language&#x3D;objc</a></li>
</ul>
]]></content>
      <tags>
        <tag>iOS业务开发</tag>
      </tags>
  </entry>
  <entry>
    <title>dyld加载流程</title>
    <url>/2024/02/01/dyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>对于小型APP来说，如果本身启动时执行的方法并不算多，那么二进制重排的意义就不是很大。对于iOS 13系统来说，由于启用了 dyld3，Page Fault发生时已经不需要执行解密验签（提前生成了lauch closure文件），对性能的影响就更小了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h2><p><a href="https://developer.aliyun.com/article/924936?spm=a2c6h.24874632.expert-profile.43.393013000BVrBO">dyld加载流程分析</a><br><a href="https://zhuanlan.zhihu.com/p/413263438">dyld64加载流程</a></p>
]]></content>
      <tags>
        <tag>iOS底层</tag>
      </tags>
  </entry>
  <entry>
    <title>单例设计模式实现方式对比</title>
    <url>/2020/03/20/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>简述了“单例模式”的实现方式, 分析了“单例模式”的优劣以及使用场景, 然后对比对照了不同实现的特点, 从底层原理出发, 分析各个实现方式都在做什么, 为什么可以这样子去做, 最后总结归纳。</p>
<span id="more"></span>

<h2 id="1-什么是单例"><a href="#1-什么是单例" class="headerlink" title="1.什么是单例"></a>1.什么是单例</h2><p>确保对于一个给定的类只有一个实例存在，这个实例有一个全局唯一的访问点。<br>可以保证在程序运行过程，一个类只有一个实例，而且该实例易于供外界访问，从而方便地控制了实例个数，并节约系统资源。</p>
<h2 id="2-单例能做什么"><a href="#2-单例能做什么" class="headerlink" title="2.单例能做什么"></a>2.单例能做什么</h2><ul>
<li>在整个应用程序中，共享一份资源（这份资源只需要创建初始化1次），这个类创建出来的对象永远只有一个。</li>
<li>使用场景：</li>
</ul>
<blockquote>
<ol>
<li>工具类 </li>
<li>频繁创建的类(比如登录页，未登录状态下，某些触发条件会调出登录页)</li>
</ol>
</blockquote>
<h2 id="3-单例的实现"><a href="#3-单例的实现" class="headerlink" title="3.单例的实现"></a>3.单例的实现</h2><h3 id="3-1-实现的方式"><a href="#3-1-实现的方式" class="headerlink" title="3.1 实现的方式"></a>3.1 实现的方式</h3><h4 id="1-命名方式："><a href="#1-命名方式：" class="headerlink" title="1&gt; 命名方式："></a>1&gt; 命名方式：</h4><blockquote>
<p>share+类名 | default + 类名 | share | 类名 </p>
</blockquote>
<p>如：<code>+(instancetype)sharedSingle;</code> </p>
<h4 id="2-实现代码"><a href="#2-实现代码" class="headerlink" title="2&gt; 实现代码"></a>2&gt; 实现代码</h4><h5 id="1-未使用单例："><a href="#1-未使用单例：" class="headerlink" title="1) 未使用单例："></a>1) 未使用单例：</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">RTTool</span> <span class="operator">*</span>tool_1 <span class="operator">=</span> [[<span class="type">RTTool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"><span class="type">RTTool</span> <span class="operator">*</span>tool_2 <span class="operator">=</span> [[<span class="type">RTTool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"><span class="type">RTTool</span> <span class="operator">*</span>tool_3 <span class="operator">=</span> [[<span class="type">RTTool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;<span class="subst">\n</span> tool_1:%p <span class="subst">\n</span> tool_2:%p <span class="subst">\n</span> tool_3:%p&quot;</span>,tool_1,tool_2,tool_3); </span><br></pre></td></tr></table></figure>
<p>打印对象地址：<br><img src="https://upload-images.jianshu.io/upload_images/4395241-1395e4cf9a5cc7e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="No Single.png"><br>可以观察到，三份地址都不同。 </p>
<h5 id="2-使用单例："><a href="#2-使用单例：" class="headerlink" title="2) 使用单例："></a>2) 使用单例：</h5><p><code>互斥锁</code>： </p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> RTTool *_instance; <span class="comment">//提供全局静态变量(作用域结束，本身不可修改) </span></span><br><span class="line"><span class="comment">/// 调用alloc真正实现内存分配的方法</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(_instance == <span class="literal">nil</span>) &#123;</span><br><span class="line">            _instance = [<span class="variable language_">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GCD一次代码</code>： </p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> RTTool *_instance; <span class="comment">//提供全局静态变量  </span></span><br><span class="line"><span class="comment">/// 调用alloc真正实现内存分配的方法</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="comment">// 参数取地址的好处？</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [<span class="variable language_">super</span> allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>打印对象地址： </p>
<p><img src="https://upload-images.jianshu.io/upload_images/4395241-beda448439efbf33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Single.png">  </p>
<p>可以观察到，三份地址<code>完全相同</code>。 </p>
<h5 id="提供可供外界访问的便捷方法"><a href="#提供可供外界访问的便捷方法" class="headerlink" title="提供可供外界访问的便捷方法"></a>提供可供外界访问的便捷方法</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> RTTool *_instance; <span class="comment">//提供全局静态变量</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shareManager &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="comment">// 参数取地址的好处？</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//+ (instancetype)shareManager &#123;</span></span><br><span class="line"><span class="comment">//    return [[self alloc] init];</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后我们就可以这样调用 </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">RTTool</span> <span class="operator">*</span>tool_1 <span class="operator">=</span> [[<span class="type">RTTool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"><span class="type">RTTool</span> <span class="operator">*</span>tool_2 <span class="operator">=</span> [[<span class="type">RTTool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"><span class="type">RTTool</span> <span class="operator">*</span>tool_3 <span class="operator">=</span> [[<span class="type">RTTool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"><span class="type">RTTool</span> <span class="operator">*</span>tool_4 <span class="operator">=</span> [<span class="type">RTTool</span> shareManager]; <span class="comment">//便捷访问方法</span></span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;<span class="subst">\n</span> tool_1:%p <span class="subst">\n</span> tool_2:%p <span class="subst">\n</span> tool_3:%p <span class="subst">\n</span> tool_4:%p&quot;</span>,tool_1,tool_2,tool_3,tool_4);</span><br></pre></td></tr></table></figure>
<h5 id="完整的Singleton实现方式"><a href="#完整的Singleton实现方式" class="headerlink" title="完整的Singleton实现方式"></a>完整的Singleton实现方式</h5><p>需要遵守拷贝协议</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">interface</span> <span class="symbol">RTTool</span>()&lt;<span class="symbol">NSCopying</span>,<span class="symbol">NSMutableCopying</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> RTTool *_instance; <span class="comment">//提供全局静态变量</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shareManager &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="comment">// 参数取地址的好处？</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//+ (instancetype)shareManager &#123;</span></span><br><span class="line"><span class="comment">//    return [[self alloc] init];</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">/// MARK: - 拷贝操作的时候，我们的_instance已经存在了，直接返回给调用方即可</span></span><br><span class="line">- (<span class="type">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="调用及结果："><a href="#调用及结果：" class="headerlink" title="调用及结果："></a>调用及结果：</h5><p><img src="https://upload-images.jianshu.io/upload_images/4395241-3ee5df2156a65c19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Single.png"></p>
<h4 id="3-2-static的作用"><a href="#3-2-static的作用" class="headerlink" title="3.2 static的作用"></a>3.2 static的作用</h4><p>编译时分配内存，程序结束时释放内存单元。</p>
<h5 id="3-2-1-作用于变量"><a href="#3-2-1-作用于变量" class="headerlink" title="3.2.1 作用于变量"></a>3.2.1 作用于变量</h5><p>作用范围：本文件内部有效&#x2F;本作用域有效。</p>
<ul>
<li>1.局部变量<br>改变变量的存储方式（生命期），使变量成为静态的局部变量。即编译时就为变量分配内存，直到程序退出才释放存储单元。<br>延长局部变量的生命周期，作用范围为局部变量作用域。<br>好处：使得该局部变量有记忆功能，可以记忆上次的数据，不过由于仍是局部变量，因而只能在代码块内部使用（作用域不变）。<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> a; <span class="comment">//作用范围为本代码块结束</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>2.全局变量<br>限制某些外部变量的作用域，使其只在本文件中有效，而不能被其他文件引用。(本文单例模式static全局变量的作用即此)</li>
</ul>
<h5 id="3-2-2-作用于函数"><a href="#3-2-2-作用于函数" class="headerlink" title="3.2.2 作用于函数"></a>3.2.2 作用于函数</h5><p>使用static用于函数定义时，对函数的连接方式产生影响，使得函数只在本文件内部有效，对其他文件是不可见的。这样的函数又叫作静态函数。使用静态函数的好处是，不用担心与其他文件的同名函数产生干扰，另外也是对函数本身的一种保护机制。</p>
<p>如果想要其他文件可以引用本地函数，则要在函数定义时使用关键字extern，表示该函数是外部函数，可供其他文件调用。另外在要引用别的文件中定义的外部函数的文件中，使用extern声明要用的外部函数即可。</p>
<h5 id="3-3-synchronized作用"><a href="#3-3-synchronized作用" class="headerlink" title="3.3 @synchronized作用"></a>3.3 @synchronized作用</h5><p>@synchronized 的作用是创建一个互斥锁，保证此时没有其它线程对self对象进行修改，保证代码的安全性。也就是包装这段代码是原子性的，安全的。这个是objective-c的一个锁定令牌，防止self对象在同一时间内被其他线程访问，起到保护线程安全的作用。<br>更多使用细节<a href="http://www.cocoachina.com/articles/18279">可查看链接</a>。<br>我们在此处不推荐使用@synchronized的原因(<a href="https://www.jianshu.com/p/ef3f77c8b320">更多原因点击查看</a>)：</p>
<ul>
<li>1.@synchronized速度慢，消耗CPU资源比较大。</li>
<li>2.外部调用可能导致死锁。</li>
</ul>
<h5 id="3-4-dispatch-once为什么能保证线程安全，参数取地址的好处"><a href="#3-4-dispatch-once为什么能保证线程安全，参数取地址的好处" class="headerlink" title="3.4 dispatch_once为什么能保证线程安全，参数取地址的好处"></a>3.4 dispatch_once为什么能保证线程安全，参数取地址的好处</h5><ul>
<li><ol>
<li><a href="http://lingyuncxb.com/2018/02/01/GCD%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902%20%E2%80%94%E2%80%94%20dispatch-once%E7%AF%87/">dispatch_once</a>为什么能保证线程安全<br>核心函数dispatch_once_f：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dispatch_once_f</span><span class="params">(<span class="type">dispatch_once_t</span> *val, <span class="type">void</span> *ctxt, <span class="type">void</span> (*func)(<span class="type">void</span> *))</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> *vval = val;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dispatch_atomic_cmpxchg</span>(val, <span class="number">0l</span>, <span class="number">1l</span>)) &#123;</span><br><span class="line">        <span class="built_in">func</span>(ctxt); <span class="comment">// block真正执行</span></span><br><span class="line">        <span class="built_in">dispatch_atomic_barrier</span>();</span><br><span class="line">        *val = ~<span class="number">0l</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            _dispatch_hardware_pause();</span><br><span class="line">        &#125; <span class="keyword">while</span> (*vval != ~<span class="number">0l</span>);</span><br><span class="line">        <span class="built_in">dispatch_atomic_barrier</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
参见dispatch_once源码，其核心函数dispatch_once_f源码分析：<br>某一个线程A首次进入dispatch_once_f，执行传入dispatch_once_f的block，然后调用dispatch_atomic_barrier；dispatch_atomic_barrier是一种内存屏障，串行化读写操作和解决顺序一致性问题，等屏障前的指令执行完了，屏障后的指令才能开始执行。<br>在首个线程A执行block的过程中，如果其它的线程也进入dispatch_once_f，执行方法就会走到else分支，调用_dispatch_hardware_pause，它干的事情就是延迟空等，这样做有助于提高性能和节省CPU耗电。<br>首个线程已经将block执行完毕，dispatch_atomic_barrier退出，这就保证了在dispatch_once_f的block的执行的唯一性，生成的单例也是唯一的。<br><strong>注:</strong><a href="https://blog.csdn.net/u014600626/article/details/102862777">dispatch_once的缺点</a></li>
</ol>
</li>
<li>2.参数取地址的<a href="https://www.jianshu.com/p/bb0d47e0b26e">好处</a></li>
</ul>
<h5 id="3-5-NSCopying-NSMutableCopying"><a href="#3-5-NSCopying-NSMutableCopying" class="headerlink" title="3.5 NSCopying,NSMutableCopying"></a>3.5 NSCopying,NSMutableCopying</h5><p>这部分很简单详情见<a href="https://www.jianshu.com/p/e98e6e30ebda">链接</a></p>
<h2 id="4-单例的优缺点"><a href="#4-单例的优缺点" class="headerlink" title="4.单例的优缺点"></a>4.单例的优缺点</h2><p>更多说明：<a href="https://www.jianshu.com/p/1aaa1256d641">参看链接</a> </p>
<p><strong>优点 :</strong>  </p>
<blockquote>
<p>1、由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。  </p>
<p>2、由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决；  </p>
<p>3、单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。  </p>
<p>4、单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。 </p>
</blockquote>
<p><strong>缺点 :</strong></p>
<blockquote>
<p>1、单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。</p>
<p>2、单例模式与单一职责原则有冲突。</p>
</blockquote>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>除单一设计原则与允许可扩展需求外，单例设计在性能优化以及减少内存占用方面具有非常良好的表现。</p>
<h4 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h4><ul>
<li>static: <a href="https://www.jianshu.com/p/512b97c89297">https://www.jianshu.com/p/512b97c89297</a>  </li>
<li>@synchronized：<a href="http://www.cocoachina.com/articles/18279">http://www.cocoachina.com/articles/18279</a></li>
<li>多线程安全: <a href="https://www.jianshu.com/p/ef3f77c8b320">https://www.jianshu.com/p/ef3f77c8b320</a></li>
<li>dispatch_once:<br>1.<a href="https://developer.apple.com/documentation/dispatch/1447169-dispatch_once?language=occ">https://developer.apple.com/documentation/dispatch/1447169-dispatch_once?language&#x3D;occ</a><br>2.<a href="https://opensource.apple.com/source/libdispatch/libdispatch-84.5/src/once.c.auto.html">https://opensource.apple.com/source/libdispatch/libdispatch-84.5/src/once.c.auto.html</a><br>3.<a href="http://lingyuncxb.com/2018/02/01/GCD%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902%20%E2%80%94%E2%80%94%20dispatch-once%E7%AF%87/">http://lingyuncxb.com/2018/02/01/GCD%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902%20%E2%80%94%E2%80%94%20dispatch-once%E7%AF%87/</a><br><a href="https://blog.csdn.net/u014600626/article/details/102862777">https://blog.csdn.net/u014600626/article/details/102862777</a></li>
</ul>
<ol start="4">
<li>参数问题：<a href="https://www.jianshu.com/p/bb0d47e0b26e">https://www.jianshu.com/p/bb0d47e0b26e</a></li>
<li>单例优劣：<a href="https://www.jianshu.com/p/1aaa1256d641">https://www.jianshu.com/p/1aaa1256d641</a></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS底层原理</tag>
      </tags>
  </entry>
</search>
